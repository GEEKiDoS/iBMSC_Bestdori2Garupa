// Generated by https://quicktype.io

namespace Bestdori
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Chart
    {
        [JsonProperty("result")]
        public bool Result { get; set; }

        [JsonProperty("post")]
        public Post Post { get; set; }
    }

    public partial class Post
    {
        [JsonProperty("categoryName")]
        public string CategoryName { get; set; }

        [JsonProperty("categoryId")]
        public string CategoryId { get; set; }

        [JsonProperty("title")]
        public string Title { get; set; }

        [JsonProperty("song")]
        public Song Song { get; set; }

        [JsonProperty("artists")]
        public string Artists { get; set; }

        [JsonProperty("diff")]
        public long Diff { get; set; }

        [JsonProperty("level")]
        public long Level { get; set; }

        [JsonProperty("notes")]
        public NoteElement[] Notes { get; set; }

        [JsonProperty("graphicsChart")]
        public Graphics[] GraphicsChart { get; set; }

        [JsonProperty("graphicsSimulator")]
        public Graphics[] GraphicsSimulator { get; set; }

        [JsonProperty("content")]
        public Content[] Content { get; set; }

        [JsonProperty("time")]
        public long Time { get; set; }

        [JsonProperty("author")]
        public Author Author { get; set; }

        [JsonProperty("likes")]
        public long Likes { get; set; }

        [JsonProperty("liked")]
        public bool Liked { get; set; }

        [JsonProperty("tags")]
        public object[] Tags { get; set; }
    }

    public partial class Author
    {
        [JsonProperty("username")]
        public string Username { get; set; }

        [JsonProperty("nickname")]
        public object Nickname { get; set; }

        [JsonProperty("titles")]
        public object Titles { get; set; }
    }

    public partial class Content
    {
        [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
        public string Data { get; set; }

        [JsonProperty("type")]
        public string Type { get; set; }
    }

    public partial class Graphics
    {
        [JsonProperty("bpm", NullValueHandling = NullValueHandling.Ignore)]
        public long? Bpm { get; set; }

        [JsonProperty("time")]
        public Time Time { get; set; }

        [JsonProperty("type")]
        public CmdEnum Type { get; set; }

        [JsonProperty("lane", NullValueHandling = NullValueHandling.Ignore)]
        public Lane? Lane { get; set; }
    }

    public partial class NoteElement
    {
        [JsonProperty("bpm", NullValueHandling = NullValueHandling.Ignore)]
        public long? Bpm { get; set; }

        [JsonProperty("cmd", NullValueHandling = NullValueHandling.Ignore)]
        public CmdEnum? Cmd { get; set; }

        [JsonProperty("beat")]
        public double Beat { get; set; }

        [JsonProperty("type")]
        public PurpleType Type { get; set; }

        [JsonProperty("lane", NullValueHandling = NullValueHandling.Ignore)]
        public long? Lane { get; set; }

        [JsonProperty("note", NullValueHandling = NullValueHandling.Ignore)]
        public NoteEnum? Note { get; set; }

        [JsonProperty("flick", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Flick { get; set; }

        [JsonProperty("pos", NullValueHandling = NullValueHandling.Ignore)]
        public Pos? Pos { get; set; }

        [JsonProperty("start", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Start { get; set; }

        [JsonProperty("end", NullValueHandling = NullValueHandling.Ignore)]
        public bool? End { get; set; }
    }

    public partial class Song
    {
        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("audio")]
        public Uri Audio { get; set; }

        [JsonProperty("cover")]
        public Uri Cover { get; set; }
    }

    public enum CmdEnum { Bar, Bpm, Flick, Long, Sim, Single, SingleOff, Tick };

    public enum NoteEnum { Single, Slide };

    public enum Pos { A, B };

    public enum PurpleType { Note, System };

    public partial struct Lane
    {
        public long? Integer;
        public long[] IntegerArray;

        public static implicit operator Lane(long Integer) => new Lane { Integer = Integer };
        public static implicit operator Lane(long[] IntegerArray) => new Lane { IntegerArray = IntegerArray };
    }

    public partial struct Time
    {
        public double? Double;
        public double[] DoubleArray;

        public static implicit operator Time(double Double) => new Time { Double = Double };
        public static implicit operator Time(double[] DoubleArray) => new Time { DoubleArray = DoubleArray };
    }

    public partial class Chart
    {
        public static Chart FromJson(string json) => JsonConvert.DeserializeObject<Chart>(json, Bestdori.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Chart self) => JsonConvert.SerializeObject(self, Bestdori.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters = {
                LaneConverter.Singleton,
                TimeConverter.Singleton,
                CmdEnumConverter.Singleton,
                NoteEnumConverter.Singleton,
                PosConverter.Singleton,
                PurpleTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class LaneConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Lane) || t == typeof(Lane?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new Lane { Integer = integerValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<long[]>(reader);
                    return new Lane { IntegerArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Lane");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Lane)untypedValue;
            if (value.Integer != null)
            {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.IntegerArray != null)
            {
                serializer.Serialize(writer, value.IntegerArray);
                return;
            }
            throw new Exception("Cannot marshal type Lane");
        }

        public static readonly LaneConverter Singleton = new LaneConverter();
    }

    internal class TimeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Time) || t == typeof(Time?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Time { Double = doubleValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<double[]>(reader);
                    return new Time { DoubleArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Time");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Time)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.DoubleArray != null)
            {
                serializer.Serialize(writer, value.DoubleArray);
                return;
            }
            throw new Exception("Cannot marshal type Time");
        }

        public static readonly TimeConverter Singleton = new TimeConverter();
    }

    internal class CmdEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CmdEnum) || t == typeof(CmdEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "BPM":
                    return CmdEnum.Bpm;
                case "Bar":
                    return CmdEnum.Bar;
                case "Flick":
                    return CmdEnum.Flick;
                case "Long":
                    return CmdEnum.Long;
                case "Sim":
                    return CmdEnum.Sim;
                case "Single":
                    return CmdEnum.Single;
                case "SingleOff":
                    return CmdEnum.SingleOff;
                case "Tick":
                    return CmdEnum.Tick;
            }
            throw new Exception("Cannot unmarshal type CmdEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CmdEnum)untypedValue;
            switch (value)
            {
                case CmdEnum.Bpm:
                    serializer.Serialize(writer, "BPM");
                    return;
                case CmdEnum.Bar:
                    serializer.Serialize(writer, "Bar");
                    return;
                case CmdEnum.Flick:
                    serializer.Serialize(writer, "Flick");
                    return;
                case CmdEnum.Long:
                    serializer.Serialize(writer, "Long");
                    return;
                case CmdEnum.Sim:
                    serializer.Serialize(writer, "Sim");
                    return;
                case CmdEnum.Single:
                    serializer.Serialize(writer, "Single");
                    return;
                case CmdEnum.SingleOff:
                    serializer.Serialize(writer, "SingleOff");
                    return;
                case CmdEnum.Tick:
                    serializer.Serialize(writer, "Tick");
                    return;
            }
            throw new Exception("Cannot marshal type CmdEnum");
        }

        public static readonly CmdEnumConverter Singleton = new CmdEnumConverter();
    }

    internal class NoteEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(NoteEnum) || t == typeof(NoteEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Single":
                    return NoteEnum.Single;
                case "Slide":
                    return NoteEnum.Slide;
            }
            throw new Exception("Cannot unmarshal type NoteEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (NoteEnum)untypedValue;
            switch (value)
            {
                case NoteEnum.Single:
                    serializer.Serialize(writer, "Single");
                    return;
                case NoteEnum.Slide:
                    serializer.Serialize(writer, "Slide");
                    return;
            }
            throw new Exception("Cannot marshal type NoteEnum");
        }

        public static readonly NoteEnumConverter Singleton = new NoteEnumConverter();
    }

    internal class PosConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Pos) || t == typeof(Pos?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "A":
                    return Pos.A;
                case "B":
                    return Pos.B;
            }
            throw new Exception("Cannot unmarshal type Pos");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Pos)untypedValue;
            switch (value)
            {
                case Pos.A:
                    serializer.Serialize(writer, "A");
                    return;
                case Pos.B:
                    serializer.Serialize(writer, "B");
                    return;
            }
            throw new Exception("Cannot marshal type Pos");
        }

        public static readonly PosConverter Singleton = new PosConverter();
    }

    internal class PurpleTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PurpleType) || t == typeof(PurpleType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Note":
                    return PurpleType.Note;
                case "System":
                    return PurpleType.System;
            }
            throw new Exception("Cannot unmarshal type PurpleType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PurpleType)untypedValue;
            switch (value)
            {
                case PurpleType.Note:
                    serializer.Serialize(writer, "Note");
                    return;
                case PurpleType.System:
                    serializer.Serialize(writer, "System");
                    return;
            }
            throw new Exception("Cannot marshal type PurpleType");
        }

        public static readonly PurpleTypeConverter Singleton = new PurpleTypeConverter();
    }
}
